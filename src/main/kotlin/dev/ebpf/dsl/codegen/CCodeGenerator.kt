package dev.ebpf.dsl.codegen

import dev.ebpf.dsl.api.BpfProgramModel
import dev.ebpf.dsl.api.ProgramDef
import dev.ebpf.dsl.ir.*
import dev.ebpf.dsl.maps.MapDecl
import dev.ebpf.dsl.maps.MapType
import dev.ebpf.dsl.programs.ProgramType
import dev.ebpf.dsl.types.*

class CCodeGenerator(private val model: BpfProgramModel) {

    // Track variables that are pointers (from IfNonNull)
    private val pointerVars = mutableSetOf<String>()

    fun generate(): String {
        pointerVars.clear()
        // Pre-scan all programs to find pointer variables from IfNonNull
        for (prog in model.programs) {
            collectPointerVars(prog.body)
        }

        val sb = StringBuilder()
        sb.appendLine("// AUTO-GENERATED by kotlin-ebpf-dsl â€” do not edit")
        sb.appendLine()

        // Includes
        sb.appendLine("#include \"vmlinux.h\"")
        sb.appendLine("#include <bpf/bpf_helpers.h>")
        sb.appendLine("#include <bpf/bpf_tracing.h>")
        sb.appendLine("#include <bpf/bpf_core_read.h>")
        sb.appendLine()

        // License
        if (model.license != null) {
            sb.appendLine("char LICENSE[] SEC(\"license\") = \"${model.license}\";")
            sb.appendLine()
        }

        // Preamble (raw C helpers, macros, etc.)
        if (model.preamble != null) {
            sb.appendLine(model.preamble)
            sb.appendLine()
        }

        // Structs
        for (struct in model.structs) {
            renderStruct(sb, struct)
            sb.appendLine()
        }

        // Maps
        for (map in model.maps) {
            renderMap(sb, map)
            sb.appendLine()
        }

        // Programs
        for (prog in model.programs) {
            renderProgram(sb, prog)
            sb.appendLine()
        }

        return sb.toString().trimEnd() + "\n"
    }

    private fun collectPointerVars(stmts: List<BpfStmt>) {
        for (stmt in stmts) {
            when (stmt) {
                is BpfStmt.IfNonNull -> {
                    pointerVars.add(stmt.variable.name)
                    collectPointerVars(stmt.body)
                    stmt.else_?.let { collectPointerVars(it) }
                }
                is BpfStmt.If -> {
                    collectPointerVars(stmt.then)
                    for ((_, body) in stmt.elseIfs) {
                        collectPointerVars(body)
                    }
                    stmt.else_?.let { collectPointerVars(it) }
                }
                is BpfStmt.BoundedLoop -> {
                    collectPointerVars(stmt.body)
                }
                else -> {}
            }
        }
    }

    private fun renderStruct(sb: StringBuilder, struct: BpfStruct) {
        sb.appendLine("struct ${struct.cName} {")
        for (field in struct.fields) {
            when (val type = field.type) {
                is BpfArrayType -> {
                    sb.appendLine("    ${type.elementType.cName} ${field.name}[${type.length}];")
                }
                else -> {
                    sb.appendLine("    ${type.cName} ${field.name};")
                }
            }
        }
        sb.appendLine("};")
    }

    private fun renderMap(sb: StringBuilder, map: MapDecl) {
        sb.appendLine("struct {")
        sb.appendLine("    __uint(type, ${map.mapType.cName});")
        sb.appendLine("    __uint(max_entries, ${map.maxEntries});")
        if (map.keyType != null) {
            sb.appendLine("    __type(key, ${renderTypeName(map.keyType)});")
        }
        if (map.valueType != null) {
            sb.appendLine("    __type(value, ${renderTypeName(map.valueType)});")
        }
        sb.appendLine("} ${map.name} SEC(\".maps\");")
    }

    private fun renderTypeName(type: BpfType): String = when (type) {
        is BpfStruct -> "struct ${type.cName}"
        is BpfScalar -> type.cName
        is BpfArrayType -> type.cName
        else -> type.cName
    }

    private fun renderProgram(sb: StringBuilder, prog: ProgramDef) {
        val ctxType = contextType(prog.type)
        sb.appendLine("SEC(\"${prog.type.sectionPrefix}\")")
        sb.appendLine("int ${prog.name}($ctxType)")
        sb.appendLine("{")
        for (stmt in prog.body) {
            renderStmt(sb, stmt, indent = 1)
        }
        sb.appendLine("}")
    }

    private fun contextType(type: ProgramType): String = when (type) {
        is ProgramType.Kprobe -> "struct pt_regs *ctx"
        is ProgramType.Kretprobe -> "struct pt_regs *ctx"
        is ProgramType.Xdp -> "struct xdp_md *ctx"
        is ProgramType.TcClassifier -> "struct __sk_buff *ctx"
        is ProgramType.RawTracepoint -> "struct bpf_raw_tracepoint_args *ctx"
        is ProgramType.CgroupSkb -> "struct __sk_buff *ctx"
        is ProgramType.SockOps -> "struct bpf_sock_ops *ctx"
        else -> "void *ctx"
    }

    private fun renderStmt(sb: StringBuilder, stmt: BpfStmt, indent: Int) {
        val pad = "    ".repeat(indent)
        when (stmt) {
            is BpfStmt.VarDecl -> {
                val v = stmt.variable
                when (val type = v.type) {
                    is BpfStruct -> {
                        sb.appendLine("${pad}struct ${type.cName} ${v.name} = {};")
                    }
                    is BpfScalar -> {
                        sb.appendLine("${pad}${type.cName} ${v.name} = ${renderExpr(stmt.init)};")
                    }
                    is BpfArrayType -> {
                        sb.appendLine("${pad}${type.elementType.cName} ${v.name}[${type.length}] = {};")
                    }
                    else -> {
                        sb.appendLine("${pad}${type.cName} ${v.name} = ${renderExpr(stmt.init)};")
                    }
                }
            }
            is BpfStmt.Assign -> {
                sb.appendLine("${pad}${renderExpr(stmt.target)} = ${renderExpr(stmt.value)};")
            }
            is BpfStmt.If -> {
                sb.appendLine("${pad}if (${renderExpr(stmt.cond)}) {")
                for (s in stmt.then) renderStmt(sb, s, indent + 1)
                for ((cond, body) in stmt.elseIfs) {
                    sb.appendLine("${pad}} else if (${renderExpr(cond)}) {")
                    for (s in body) renderStmt(sb, s, indent + 1)
                }
                if (stmt.else_ != null) {
                    sb.appendLine("${pad}} else {")
                    for (s in stmt.else_) renderStmt(sb, s, indent + 1)
                }
                sb.appendLine("${pad}}")
            }
            is BpfStmt.IfNonNull -> {
                val v = stmt.variable
                val valueTypeName = renderTypeName(v.type)
                sb.appendLine("${pad}${valueTypeName} *${v.name} = ${renderExpr(stmt.expr)};")
                sb.appendLine("${pad}if (${v.name}) {")
                for (s in stmt.body) renderStmt(sb, s, indent + 1)
                if (stmt.else_ != null) {
                    sb.appendLine("${pad}} else {")
                    for (s in stmt.else_) renderStmt(sb, s, indent + 1)
                }
                sb.appendLine("${pad}}")
            }
            is BpfStmt.Return -> {
                sb.appendLine("${pad}return ${renderExpr(stmt.value)};")
            }
            is BpfStmt.AtomicOp -> {
                val funcName = atomicFuncName(stmt.op)
                sb.appendLine("${pad}${funcName}(&${renderExpr(stmt.target)}, ${renderExpr(stmt.operand)});")
            }
            is BpfStmt.BoundedLoop -> {
                val iterName = stmt.iterVar.name
                sb.appendLine("${pad}#pragma unroll")
                sb.appendLine("${pad}for (__u32 ${iterName} = 0; ${iterName} < ${renderExpr(stmt.count)}; ${iterName}++) {")
                for (s in stmt.body) renderStmt(sb, s, indent + 1)
                sb.appendLine("${pad}}")
            }
            is BpfStmt.MapDelete -> {
                sb.appendLine("${pad}bpf_map_delete_elem(&${stmt.mapName}, &${renderExpr(stmt.key)});")
            }
            is BpfStmt.ExprStmt -> {
                sb.appendLine("${pad}${renderExpr(stmt.expr)};")
            }
        }
    }

    private fun atomicFuncName(op: AtomicOpKind): String = when (op) {
        AtomicOpKind.ADD -> "__sync_fetch_and_add"
        AtomicOpKind.SUB -> "__sync_fetch_and_sub"
        AtomicOpKind.OR -> "__sync_fetch_and_or"
        AtomicOpKind.AND -> "__sync_fetch_and_and"
        AtomicOpKind.XOR -> "__sync_fetch_and_xor"
        AtomicOpKind.XCHG -> "__sync_lock_test_and_set"
        AtomicOpKind.CMPXCHG -> "__sync_val_compare_and_swap"
    }

    private fun renderExpr(expr: BpfExpr): String = when (expr) {
        is BpfExpr.Literal -> renderLiteral(expr)
        is BpfExpr.VarRef -> expr.variable.name
        is BpfExpr.BinaryOp -> "(${renderExpr(expr.left)} ${opSymbol(expr.op)} ${renderExpr(expr.right)})"
        is BpfExpr.UnaryOp -> renderUnaryOp(expr)
        is BpfExpr.FieldAccess -> renderFieldAccess(expr)
        is BpfExpr.ArrayIndex -> "${renderExpr(expr.base)}[${renderExpr(expr.index)}]"
        is BpfExpr.HelperCall -> "${expr.helperName}(${expr.args.joinToString(", ") { renderExpr(it) }})"
        is BpfExpr.Cast -> "(${(expr.target).cName})${renderExpr(expr.expr)}"
        is BpfExpr.Raw -> expr.cCode
        is BpfExpr.Deref -> "*${renderExpr(expr.operand)}"
        is BpfExpr.TracepointField -> "((struct ${expr.structName} *)ctx)->${expr.fieldName}"
        is BpfExpr.KprobeParam -> "(${expr.castType})PT_REGS_PARM${expr.index}(ctx)"
        is BpfExpr.RawTpArg -> "(${expr.castType})ctx->args[${expr.index}]"
        is BpfExpr.HistSlot -> "log2l(${renderExpr(expr.value)}) >= ${expr.maxSlots} ? ${expr.maxSlots - 1} : log2l(${renderExpr(expr.value)})"
        is BpfExpr.Ternary -> "(${renderExpr(expr.cond)}) ? ${renderExpr(expr.then)} : ${renderExpr(expr.else_)}"
        is BpfExpr.StructArraySet -> "(${renderExpr(expr.structVar)}.${expr.field.name}[${renderExpr(expr.index)}] = ${renderExpr(expr.value)}, (__s32)0)"
        is BpfExpr.CTypeCast -> "(${expr.cTypeName})${renderExpr(expr.operand)}"
        is BpfExpr.MapLookup -> "bpf_map_lookup_elem(&${expr.mapName}, &${renderExpr(expr.key)})"
        is BpfExpr.MapUpdate -> "bpf_map_update_elem(&${expr.mapName}, &${renderExpr(expr.key)}, &${renderExpr(expr.value)}, ${expr.flags})"
    }

    private fun renderLiteral(lit: BpfExpr.Literal): String {
        val v = lit.value
        return when (lit.type) {
            is BpfScalar.U64 -> "${v}ULL"
            is BpfScalar.U32 -> "${v}U"
            is BpfScalar.U16 -> "${v}U"
            is BpfScalar.U8 -> "${v}U"
            else -> "$v"
        }
    }

    private fun opSymbol(op: Op): String = when (op) {
        Op.ADD -> "+"
        Op.SUB -> "-"
        Op.MUL -> "*"
        Op.DIV -> "/"
        Op.MOD -> "%"
        Op.AND -> "&"
        Op.OR -> "|"
        Op.XOR -> "^"
        Op.SHL -> "<<"
        Op.SHR -> ">>"
        Op.EQ -> "=="
        Op.NE -> "!="
        Op.GT -> ">"
        Op.GE -> ">="
        Op.LT -> "<"
        Op.LE -> "<="
        Op.NOT -> "!"
        Op.INV -> "~"
        Op.NEG -> "-"
    }

    private fun renderUnaryOp(expr: BpfExpr.UnaryOp): String {
        val sym = opSymbol(expr.op)
        return "${sym}(${renderExpr(expr.operand)})"
    }

    private fun renderFieldAccess(expr: BpfExpr.FieldAccess): String {
        val base = expr.base
        val isPointer = base is BpfExpr.VarRef && base.variable.name in pointerVars
        val op = if (isPointer) "->" else "."
        return "${renderExpr(base)}${op}${expr.field.name}"
    }
}

package dev.ebpf.dsl.codegen

import dev.ebpf.dsl.api.BpfProgramModel
import dev.ebpf.dsl.maps.MapDecl
import dev.ebpf.dsl.maps.MapType
import dev.ebpf.dsl.types.*

class KotlinCodeGenerator(
    private val model: BpfProgramModel,
    private val packageName: String,
    private val bridgeImport: String? = null,
) {
    // Maps that have both key and value types (skip ringbuf, perf_event_array, etc.)
    private val readableMaps: List<MapDecl> by lazy {
        model.maps.filter { it.keyType != null && it.valueType != null }
    }

    // Collect unique structs used as keys and values in readable maps
    private val keyStructs: Set<BpfStruct> by lazy {
        readableMaps.mapNotNull { it.keyType as? BpfStruct }.toSet()
    }
    private val valueStructs: Set<BpfStruct> by lazy {
        readableMaps.mapNotNull { it.valueType as? BpfStruct }.toSet()
    }
    private val allMapStructs: Set<BpfStruct> by lazy {
        keyStructs + valueStructs
    }

    fun generate(): String {
        val sb = StringBuilder()

        sb.appendLine("// AUTO-GENERATED by kotlin-ebpf-dsl â€” do not edit")
        sb.appendLine("package $packageName")
        sb.appendLine()
        sb.appendLine("import java.nio.ByteBuffer")
        sb.appendLine("import java.nio.ByteOrder")
        if (bridgeImport != null) {
            sb.appendLine("import $bridgeImport")
        }
        sb.appendLine()

        val className = buildClassName(model.name)
        sb.appendLine("class $className {")
        sb.appendLine()

        // Layout objects
        for (struct in allMapStructs) {
            renderLayoutObject(sb, struct)
            sb.appendLine()
        }

        // Data classes (one per unique key+value pair)
        val renderedDataClasses = mutableSetOf<String>()
        for (map in readableMaps) {
            val keyStruct = map.keyType as? BpfStruct ?: continue
            val valueStruct = map.valueType as? BpfStruct ?: continue
            val dataClassName = buildDataClassName(keyStruct, valueStruct)
            if (renderedDataClasses.add(dataClassName)) {
                renderDataClass(sb, dataClassName, keyStruct, valueStruct)
                sb.appendLine()
            }
        }

        // Reader methods
        for (map in readableMaps) {
            val keyStruct = map.keyType as? BpfStruct ?: continue
            val valueStruct = map.valueType as? BpfStruct ?: continue
            renderReaderMethod(sb, map, keyStruct, valueStruct)
            sb.appendLine()
        }

        sb.appendLine("}")

        return sb.toString().trimEnd() + "\n"
    }

    private fun buildClassName(name: String): String {
        return name.split("_", "-").joinToString("") {
            it.replaceFirstChar { c -> c.uppercaseChar() }
        } + "MapReader"
    }

    private fun layoutObjectName(struct: BpfStruct): String {
        return struct.cName.split("_").joinToString("") {
            it.replaceFirstChar { c -> c.uppercaseChar() }
        } + "Layout"
    }

    private fun buildDataClassName(key: BpfStruct, value: BpfStruct): String {
        // Use the value struct name to derive the data class name, dropping "_value" suffix if present
        val baseName = value.cName.removeSuffix("_value").removeSuffix("_val")
        return baseName.split("_").joinToString("") {
            it.replaceFirstChar { c -> c.uppercaseChar() }
        } + "Entry"
    }

    private fun renderLayoutObject(sb: StringBuilder, struct: BpfStruct) {
        val name = layoutObjectName(struct)
        val isKey = struct in keyStructs
        val isValue = struct in valueStructs

        sb.appendLine("    object $name {")
        sb.appendLine("        const val SIZE = ${struct.sizeBytes}")

        // Offset constants
        for (field in struct.fields) {
            val constName = fieldConstName(field)
            sb.appendLine("        const val ${constName}_OFFSET = ${field.offset}")
        }
        sb.appendLine()

        // Encode method for key structs
        if (isKey) {
            renderEncodeMethod(sb, struct)
            sb.appendLine()
        }

        // Decode methods for all fields
        for (field in struct.fields) {
            renderDecodeMethod(sb, field)
            sb.appendLine()
        }

        sb.appendLine("    }")
    }

    private fun fieldConstName(field: StructField): String {
        return field.name.uppercase()
    }

    private fun fieldMethodSuffix(field: StructField): String {
        return field.name.split("_").joinToString("") {
            it.replaceFirstChar { c -> c.uppercaseChar() }
        }
    }

    private fun renderEncodeMethod(sb: StringBuilder, struct: BpfStruct) {
        val params = struct.fields.joinToString(", ") { f ->
            "${f.kotlinName}: ${kotlinTypeName(f.type)}"
        }
        sb.appendLine("        fun encode($params): ByteArray {")
        sb.appendLine("            val buf = ByteBuffer.allocate(SIZE).order(ByteOrder.LITTLE_ENDIAN)")
        for (field in struct.fields) {
            val constName = fieldConstName(field)
            when (val type = field.type) {
                is BpfScalar -> {
                    val putMethod = byteBufPutMethod(type)
                    sb.appendLine("            buf.$putMethod(${constName}_OFFSET, ${field.kotlinName})")
                }
                is BpfArrayType -> {
                    val elemScalar = type.elementType as? BpfScalar
                    if (elemScalar != null) {
                        sb.appendLine("            for (i in ${field.kotlinName}.indices) {")
                        val putMethod = byteBufPutMethod(elemScalar)
                        sb.appendLine("                buf.$putMethod(${constName}_OFFSET + i * ${elemScalar.size}, ${field.kotlinName}[i])")
                        sb.appendLine("            }")
                    }
                }
                else -> {}
            }
        }
        sb.appendLine("            return buf.array()")
        sb.appendLine("        }")
    }

    private fun renderDecodeMethod(sb: StringBuilder, field: StructField) {
        val methodSuffix = fieldMethodSuffix(field)
        val constName = fieldConstName(field)
        when (val type = field.type) {
            is BpfScalar -> {
                val returnType = kotlinTypeName(type)
                val getMethod = byteBufGetMethod(type)
                sb.appendLine("        fun decode$methodSuffix(bytes: ByteArray): $returnType =")
                sb.appendLine("            ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN)")
                sb.appendLine("                .$getMethod(${constName}_OFFSET)")
            }
            is BpfArrayType -> {
                val elemScalar = type.elementType as? BpfScalar
                if (elemScalar != null) {
                    val arrayType = kotlinArrayTypeName(elemScalar)
                    val getMethod = byteBufGetMethod(elemScalar)
                    sb.appendLine("        fun decode${methodSuffix}Array(bytes: ByteArray): $arrayType {")
                    sb.appendLine("            val buf = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN)")
                    sb.appendLine("            return $arrayType(${type.length}) { i ->")
                    sb.appendLine("                buf.$getMethod(${constName}_OFFSET + i * ${elemScalar.size})")
                    sb.appendLine("            }")
                    sb.appendLine("        }")
                }
            }
            else -> {}
        }
    }

    private fun renderDataClass(sb: StringBuilder, className: String, key: BpfStruct, value: BpfStruct) {
        sb.appendLine("    data class $className(")
        val allFields = mutableListOf<Pair<StructField, BpfStruct>>()
        for (f in key.fields) allFields.add(f to key)
        for (f in value.fields) allFields.add(f to value)
        for ((i, pair) in allFields.withIndex()) {
            val (field, _) = pair
            val comma = if (i < allFields.size - 1) "," else ","
            sb.appendLine("        val ${field.kotlinName}: ${kotlinTypeName(field.type)}$comma")
        }
        sb.appendLine("    )")
    }

    private fun renderReaderMethod(sb: StringBuilder, map: MapDecl, key: BpfStruct, value: BpfStruct) {
        val methodName = "read" + map.name.split("_").joinToString("") {
            it.replaceFirstChar { c -> c.uppercaseChar() }
        }
        val dataClassName = buildDataClassName(key, value)
        val keyLayout = layoutObjectName(key)
        val valueLayout = layoutObjectName(value)

        sb.appendLine("    fun $methodName(mapFd: Int, bridge: BpfBridge, maxEntries: Int = ${map.maxEntries}): List<$dataClassName> {")
        sb.appendLine("        val entries = bridge.mapBatchLookupAndDelete(")
        sb.appendLine("            mapFd, $keyLayout.SIZE, $valueLayout.SIZE, maxEntries")
        sb.appendLine("        )")
        sb.appendLine("        return entries.map { entry ->")
        sb.appendLine("            val key = entry.first")
        sb.appendLine("            val value = entry.second")
        sb.appendLine("            $dataClassName(")

        // Key fields
        for (field in key.fields) {
            val methodSuffix = fieldMethodSuffix(field)
            when (field.type) {
                is BpfArrayType -> {
                    sb.appendLine("                ${field.kotlinName} = $keyLayout.decode${methodSuffix}Array(key),")
                }
                else -> {
                    sb.appendLine("                ${field.kotlinName} = $keyLayout.decode$methodSuffix(key),")
                }
            }
        }

        // Value fields
        for (field in value.fields) {
            val methodSuffix = fieldMethodSuffix(field)
            when (field.type) {
                is BpfArrayType -> {
                    sb.appendLine("                ${field.kotlinName} = $valueLayout.decode${methodSuffix}Array(value),")
                }
                else -> {
                    sb.appendLine("                ${field.kotlinName} = $valueLayout.decode$methodSuffix(value),")
                }
            }
        }

        sb.appendLine("            )")
        sb.appendLine("        }")
        sb.appendLine("    }")
    }

    private fun kotlinTypeName(type: BpfType): String = when (type) {
        is BpfScalar.U8, is BpfScalar.S8 -> "Byte"
        is BpfScalar.U16, is BpfScalar.S16 -> "Short"
        is BpfScalar.U32, is BpfScalar.S32 -> "Int"
        is BpfScalar.U64, is BpfScalar.S64 -> "Long"
        is BpfScalar.Bool -> "Byte"
        is BpfArrayType -> {
            when (type.elementType) {
                is BpfScalar.U64, is BpfScalar.S64 -> "LongArray"
                is BpfScalar.U32, is BpfScalar.S32 -> "IntArray"
                is BpfScalar.U16, is BpfScalar.S16 -> "ShortArray"
                is BpfScalar.U8, is BpfScalar.S8 -> "ByteArray"
                else -> "LongArray"
            }
        }
        else -> "ByteArray"
    }

    private fun kotlinArrayTypeName(scalar: BpfScalar): String = when (scalar) {
        is BpfScalar.U64, is BpfScalar.S64 -> "LongArray"
        is BpfScalar.U32, is BpfScalar.S32 -> "IntArray"
        is BpfScalar.U16, is BpfScalar.S16 -> "ShortArray"
        is BpfScalar.U8, is BpfScalar.S8 -> "ByteArray"
        is BpfScalar.Bool -> "ByteArray"
    }

    private fun byteBufPutMethod(scalar: BpfScalar): String = when (scalar) {
        is BpfScalar.U8, is BpfScalar.S8 -> "put"
        is BpfScalar.U16, is BpfScalar.S16 -> "putShort"
        is BpfScalar.U32, is BpfScalar.S32 -> "putInt"
        is BpfScalar.U64, is BpfScalar.S64 -> "putLong"
        is BpfScalar.Bool -> "put"
    }

    private fun byteBufGetMethod(scalar: BpfScalar): String = when (scalar) {
        is BpfScalar.U8, is BpfScalar.S8 -> "get"
        is BpfScalar.U16, is BpfScalar.S16 -> "getShort"
        is BpfScalar.U32, is BpfScalar.S32 -> "getInt"
        is BpfScalar.U64, is BpfScalar.S64 -> "getLong"
        is BpfScalar.Bool -> "get"
    }
}

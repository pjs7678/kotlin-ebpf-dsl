// AUTO-GENERATED by kotlin-ebpf-dsl â€” do not edit

#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>

char LICENSE[] SEC("license") = "GPL";

struct cgroup_key {
    __u64 cgroup_id;
};

struct reclaim_stats {
    __u64 count;
    __u64 total_ns;
};

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 10240);
    __type(key, __u64);
    __type(value, __u64);
} reclaim_start SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_LRU_HASH);
    __uint(max_entries, 10240);
    __type(key, struct cgroup_key);
    __type(value, struct reclaim_stats);
} reclaim_stats SEC(".maps");

SEC("tp/mm/mm_vmscan_direct_reclaim_begin")
int tp_mm_mm_vmscan_direct_reclaim_begin(void *ctx)
{
    __u64 pid_tgid = bpf_get_current_pid_tgid();
    __u64 ts = bpf_ktime_get_ns();
    bpf_map_update_elem(&reclaim_start, &pid_tgid, &ts, 0);
    return 0;
}

SEC("tp/mm/mm_vmscan_direct_reclaim_end")
int tp_mm_mm_vmscan_direct_reclaim_end(void *ctx)
{
    __u64 pid_tgid = bpf_get_current_pid_tgid();
    __u64 *entry_0 = bpf_map_lookup_elem(&reclaim_start, &pid_tgid);
    if (entry_0) {
        __u64 delta_ns = (bpf_ktime_get_ns() - *entry_0);
        bpf_map_delete_elem(&reclaim_start, &pid_tgid);
        __u64 cgroup_id = bpf_get_current_cgroup_id();
        struct cgroup_key var_1 = {};
        var_1.cgroup_id = cgroup_id;
        struct reclaim_stats *entry_2 = bpf_map_lookup_elem(&reclaim_stats, &var_1);
        if (entry_2) {
            __sync_fetch_and_add(&entry_2->count, 1ULL);
            __sync_fetch_and_add(&entry_2->total_ns, delta_ns);
        } else {
            struct reclaim_stats var_3 = {};
            var_3.count = 1ULL;
            var_3.total_ns = delta_ns;
            bpf_map_update_elem(&reclaim_stats, &var_1, &var_3, 1);
        }
    }
    return 0;
}

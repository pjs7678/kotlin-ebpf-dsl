// AUTO-GENERATED by kotlin-ebpf-dsl â€” do not edit

#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>

char LICENSE[] SEC("license") = "GPL";

#define MAX_ENTRIES 10240
#define MAX_SLOTS 27

static __always_inline __u32 log2l(__u64 v) {
    __u32 r = 0;
    while (v > 1) {
        v >>= 1;
        r++;
    }
    return r;
}

struct cgroup_key {
    __u64 cgroup_id;
};

struct tcp_stats {
    __u64 bytes_sent;
    __u64 bytes_received;
    __u64 retransmits;
    __u64 connections;
    __u64 rtt_sum_us;
    __u64 rtt_count;
};

struct hist_key {
    __u64 cgroup_id;
};

struct hist_value {
    __u64 slots[27];
    __u64 count;
    __u64 sum_ns;
};

struct {
    __uint(type, BPF_MAP_TYPE_LRU_HASH);
    __uint(max_entries, 10240);
    __type(key, struct cgroup_key);
    __type(value, struct tcp_stats);
} tcp_stats SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_LRU_HASH);
    __uint(max_entries, 10240);
    __type(key, struct hist_key);
    __type(value, struct hist_value);
} rtt_hist SEC(".maps");

SEC("kprobe/tcp_sendmsg")
int kprobe_tcp_sendmsg(struct pt_regs *ctx)
{
    __u64 size = (size_t)PT_REGS_PARM3(ctx);
    __u64 cgroup_id = bpf_get_current_cgroup_id();
    struct cgroup_key var_0 = {};
    var_0.cgroup_id = cgroup_id;
    struct tcp_stats *entry_1 = bpf_map_lookup_elem(&tcp_stats, &var_0);
    if (entry_1) {
        __sync_fetch_and_add(&entry_1->bytes_sent, size);
    } else {
        struct tcp_stats var_2 = {};
        var_2.bytes_sent = size;
        bpf_map_update_elem(&tcp_stats, &var_0, &var_2, 1);
    }
    return 0;
}

SEC("kprobe/tcp_recvmsg")
int kprobe_tcp_recvmsg(struct pt_regs *ctx)
{
    __u64 len = (size_t)PT_REGS_PARM3(ctx);
    __u64 cgroup_id = bpf_get_current_cgroup_id();
    struct cgroup_key var_0 = {};
    var_0.cgroup_id = cgroup_id;
    struct tcp_stats *entry_1 = bpf_map_lookup_elem(&tcp_stats, &var_0);
    if (entry_1) {
        __sync_fetch_and_add(&entry_1->bytes_received, len);
    } else {
        struct tcp_stats var_2 = {};
        var_2.bytes_received = len;
        bpf_map_update_elem(&tcp_stats, &var_0, &var_2, 1);
    }
    return 0;
}

SEC("tp/tcp/tcp_retransmit_skb")
int tp_tcp_tcp_retransmit_skb(void *ctx)
{
    __u64 cgroup_id = bpf_get_current_cgroup_id();
    struct cgroup_key var_0 = {};
    var_0.cgroup_id = cgroup_id;
    struct tcp_stats *entry_1 = bpf_map_lookup_elem(&tcp_stats, &var_0);
    if (entry_1) {
        __sync_fetch_and_add(&entry_1->retransmits, 1ULL);
    } else {
        struct tcp_stats var_2 = {};
        var_2.retransmits = 1ULL;
        bpf_map_update_elem(&tcp_stats, &var_0, &var_2, 1);
    }
    return 0;
}

SEC("tp/sock/inet_sock_set_state")
int tp_sock_inet_sock_set_state(void *ctx)
{
    __s32 newstate = ((struct trace_event_raw_inet_sock_set_state *)ctx)->newstate;
    __u64 cgroup_id = bpf_get_current_cgroup_id();
    if ((newstate == 1)) {
        struct cgroup_key var_0 = {};
        var_0.cgroup_id = cgroup_id;
        struct tcp_stats *entry_1 = bpf_map_lookup_elem(&tcp_stats, &var_0);
        if (entry_1) {
            __sync_fetch_and_add(&entry_1->connections, 1ULL);
        } else {
            struct tcp_stats var_2 = {};
            var_2.connections = 1ULL;
            bpf_map_update_elem(&tcp_stats, &var_0, &var_2, 1);
        }
    }
    return 0;
}

SEC("tp/tcp/tcp_probe")
int tp_tcp_tcp_probe(void *ctx)
{
    __u64 cgroup_id = bpf_get_current_cgroup_id();
    __u32 srtt_us = ((struct trace_event_raw_tcp_probe *)ctx)->srtt;
    struct cgroup_key var_0 = {};
    var_0.cgroup_id = cgroup_id;
    struct tcp_stats *entry_1 = bpf_map_lookup_elem(&tcp_stats, &var_0);
    if (entry_1) {
        __sync_fetch_and_add(&entry_1->rtt_sum_us, srtt_us);
        __sync_fetch_and_add(&entry_1->rtt_count, 1ULL);
    }
    __u64 rtt_ns = ((__u64)srtt_us * 1000ULL);
    struct hist_key var_2 = {};
    var_2.cgroup_id = cgroup_id;
    struct hist_value *entry_3 = bpf_map_lookup_elem(&rtt_hist, &var_2);
    if (entry_3) {
        __u32 slot = log2l(rtt_ns) >= 27 ? 26 : log2l(rtt_ns);
        __sync_fetch_and_add(&entry_3->slots[slot], 1ULL);
        __sync_fetch_and_add(&entry_3->count, 1ULL);
        __sync_fetch_and_add(&entry_3->sum_ns, rtt_ns);
    } else {
        __u32 slot2 = log2l(rtt_ns) >= 27 ? 26 : log2l(rtt_ns);
        struct hist_value var_4 = {};
        var_4.count = 1ULL;
        var_4.sum_ns = rtt_ns;
        __s32 _arr_set = (var_4.slots[slot2] = 1ULL, (__s32)0);
        bpf_map_update_elem(&rtt_hist, &var_2, &var_4, 1);
    }
    return 0;
}

// AUTO-GENERATED by kotlin-ebpf-dsl â€” do not edit

#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>

char LICENSE[] SEC("license") = "GPL";

#define MAX_ENTRIES 10240
#define MAX_SLOTS 27

static __always_inline __u32 log2l(__u64 v) {
    __u32 r = 0;
    while (v > 1) {
        v >>= 1;
        r++;
    }
    return r;
}

struct hist_key {
    __u64 cgroup_id;
};

struct hist_value {
    __u64 slots[27];
    __u64 count;
    __u64 sum_ns;
};

struct {
    __uint(type, BPF_MAP_TYPE_LRU_HASH);
    __uint(max_entries, 10240);
    __type(key, struct hist_key);
    __type(value, struct hist_value);
} io_size SEC(".maps");

SEC("kprobe/blk_mq_start_request")
int kprobe_blk_mq_start_request(struct pt_regs *ctx)
{
    __u64 bytes = (__u64)((struct request *)PT_REGS_PARM1(ctx))->__data_len;
    __u64 cgroup_id = bpf_get_current_cgroup_id();
    struct hist_key var_0 = {};
    var_0.cgroup_id = cgroup_id;
    struct hist_value *entry_1 = bpf_map_lookup_elem(&io_size, &var_0);
    if (entry_1) {
        __u32 slot = log2l(bytes) >= 27 ? 26 : log2l(bytes);
        __sync_fetch_and_add(&entry_1->slots[slot], 1ULL);
        __sync_fetch_and_add(&entry_1->count, 1ULL);
        __sync_fetch_and_add(&entry_1->sum_ns, bytes);
    } else {
        __u32 slot2 = log2l(bytes) >= 27 ? 26 : log2l(bytes);
        struct hist_value var_2 = {};
        var_2.count = 1ULL;
        var_2.sum_ns = bytes;
        __s32 _arr_set = (var_2.slots[slot2] = 1ULL, (__s32)0);
        bpf_map_update_elem(&io_size, &var_0, &var_2, 1);
    }
    return 0;
}
